<!DOCTYPE html>
<html lang="en" >

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Model" />
<meta property="og:description" content="数学模型
 1. 近似
 2. 增长数量级
 3. 内循环
 4. 成本模型
  注意事项
 1. 大常数
 2. 缓存
 3. 对最坏情况下的性能的保证
 4. 随机化算法
 5. 均摊分析
  ThreeSum
 1. ThreeSumSlow
 2. ThreeSumBinarySearch
 3. ThreeSumTwoPointer
  倍率实验
  数学模型 1. 近似 N3/6-N2/2&#43;N/3 ~ N3/6。使用 ~f(N) 来表示所有随着 N 的增大除以 f(N) 的结果趋近于 1 的函数。
2. 增长数量级 N3/6-N2/2&#43;N/3 的增长数量级为 O(N3)。增长数量级将算法与它的具体实现隔离开来，一个算法的增长数量级为 O(N3) 与它是否用 Java 实现，是否运行于特定计算机上无关。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jiakuanzhu.github.io/2019/10/model/" />
<meta property="article:published_time" content="2019-10-26T12:12:16+08:00" />
<meta property="article:modified_time" content="2019-10-26T12:12:16+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Model"/>
<meta name="twitter:description" content="数学模型
 1. 近似
 2. 增长数量级
 3. 内循环
 4. 成本模型
  注意事项
 1. 大常数
 2. 缓存
 3. 对最坏情况下的性能的保证
 4. 随机化算法
 5. 均摊分析
  ThreeSum
 1. ThreeSumSlow
 2. ThreeSumBinarySearch
 3. ThreeSumTwoPointer
  倍率实验
  数学模型 1. 近似 N3/6-N2/2&#43;N/3 ~ N3/6。使用 ~f(N) 来表示所有随着 N 的增大除以 f(N) 的结果趋近于 1 的函数。
2. 增长数量级 N3/6-N2/2&#43;N/3 的增长数量级为 O(N3)。增长数量级将算法与它的具体实现隔离开来，一个算法的增长数量级为 O(N3) 与它是否用 Java 实现，是否运行于特定计算机上无关。"/>
<meta name="generator" content="Hugo 0.59.0" />


    
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "Model",
  "url": "https:\/\/jiakuanzhu.github.io\/2019\/10\/model\/",
  "wordCount": "609",
  "datePublished": "2019-10-26T12:12:16+08:00",
  "dateModified": "2019-10-26T12:12:16+08:00",
  "author": {
    "@type": "Person",
    "name": "Your Name"
  }
}
</script>



    <link rel="canonical" href="https://jiakuanzhu.github.io/2019/10/model/">

    <title>Model | Hugo Bootstrap v4 Blog</title>

    
    <!-- combined, minified CSS -->
    <link href="https://jiakuanzhu.github.io/css/style.css" rel="stylesheet" integrity="sha384-G5B34w7DFTumWTswxYzTX7NWfbvQEg1HbFFEg6ItN03uTAAoS2qkPS/fu3LhuuSA" crossorigin="anonymous">
    

    <!-- RSS 2.0 feed -->
    

    

    

  </head>

  <body>

    
    <div class="blog-masthead">
      <div class="container">
        <nav class="nav blog-nav">
          <a class="nav-link " href="https://jiakuanzhu.github.io/">Home</a>
        </nav>
      </div>
    </div>
    

    
    
    <header class="blog-header">
      <div class="container">
        <h1 class="blog-title" dir="auto"><a href="https://jiakuanzhu.github.io/" rel="home">Hugo Bootstrap v4 Blog</a></h1>
        <p class="lead blog-description" dir="auto">A simple Hugo theme based on the Bootstrap v4 blog example.</p>
      </div>
    </header>
    
    

    
    <div class="container">
      <div class="row">
        <div class="col-sm-8 blog-main">

          


<article class="blog-post">
  <header>
    <h2 class="blog-post-title" dir="auto"><a href="https://jiakuanzhu.github.io/2019/10/model/">Model</a></h2>
    <p class="blog-post-meta"><time datetime="2019-10-26T12:12:16&#43;08:00">Sat Oct 26, 2019</time> by Your Name</p>
  </header>
  

<!-- GFM-TOC -->

<ul>
<li><p><a href="#数学模型">数学模型</a></p>

<ul>
<li><p><a href="#1-近似">1. 近似</a></p></li>

<li><p><a href="#2-增长数量级">2. 增长数量级</a></p></li>

<li><p><a href="#3-内循环">3. 内循环</a></p></li>

<li><p><a href="#4-成本模型">4. 成本模型</a></p></li>
</ul></li>

<li><p><a href="#注意事项">注意事项</a></p>

<ul>
<li><p><a href="#1-大常数">1. 大常数</a></p></li>

<li><p><a href="#2-缓存">2. 缓存</a></p></li>

<li><p><a href="#3-对最坏情况下的性能的保证">3. 对最坏情况下的性能的保证</a></p></li>

<li><p><a href="#4-随机化算法">4. 随机化算法</a></p></li>

<li><p><a href="#5-均摊分析">5. 均摊分析</a></p></li>
</ul></li>

<li><p><a href="#threesum">ThreeSum</a></p>

<ul>
<li><p><a href="#1-threesumslow">1. ThreeSumSlow</a></p></li>

<li><p><a href="#2-threesumbinarysearch">2. ThreeSumBinarySearch</a></p></li>

<li><p><a href="#3-threesumtwopointer">3. ThreeSumTwoPointer</a></p></li>
</ul></li>

<li><p><a href="#倍率实验">倍率实验</a></p></li>
</ul>

<!-- GFM-TOC -->

<h1 id="数学模型">数学模型</h1>

<h2 id="1-近似">1. 近似</h2>

<p>N<sup>3</sup>/6-N<sup>2</sup>/2+N/3 ~ N<sup>3</sup>/6。使用 ~f(N) 来表示所有随着 N 的增大除以 f(N) 的结果趋近于 1 的函数。</p>

<h2 id="2-增长数量级">2. 增长数量级</h2>

<p>N<sup>3</sup>/6-N<sup>2</sup>/2+N/3 的增长数量级为 O(N<sup>3</sup>)。增长数量级将算法与它的具体实现隔离开来，一个算法的增长数量级为 O(N<sup>3</sup>) 与它是否用 Java 实现，是否运行于特定计算机上无关。</p>

<h2 id="3-内循环">3. 内循环</h2>

<p>执行最频繁的指令决定了程序执行的总时间，把这些指令称为程序的内循环。</p>

<h2 id="4-成本模型">4. 成本模型</h2>

<p>使用成本模型来评估算法，例如数组的访问次数就是一种成本模型。</p>

<h1 id="注意事项">注意事项</h1>

<h2 id="1-大常数">1. 大常数</h2>

<p>在求近似时，如果低级项的常数系数很大，那么近似的结果是错误的。</p>

<h2 id="2-缓存">2. 缓存</h2>

<p>计算机系统会使用缓存技术来组织内存，访问数组相邻的元素会比访问不相邻的元素快很多。</p>

<h2 id="3-对最坏情况下的性能的保证">3. 对最坏情况下的性能的保证</h2>

<p>在核反应堆、心脏起搏器或者刹车控制器中的软件，最坏情况下的性能是十分重要的。</p>

<h2 id="4-随机化算法">4. 随机化算法</h2>

<p>通过打乱输入，去除算法对输入的依赖。</p>

<h2 id="5-均摊分析">5. 均摊分析</h2>

<p>将所有操作的总成本除于操作总数来将成本均摊。例如对一个空栈进行 N 次连续的 push() 调用需要访问数组的次数为 N+4+8+16+&hellip;+2N=5N-4（N 是向数组写入元素的次数，其余都是调整数组大小时进行复制需要的访问数组次数），均摊后访问数组的平均次数为常数。</p>

<h1 id="threesum">ThreeSum</h1>

<p>ThreeSum 用于统计一个数组中和为 0 的三元组数量。</p>

<pre><code class="language-java">
public interface ThreeSum {

    int count(int[] nums);

}

</code></pre>

<h2 id="1-threesumslow">1. ThreeSumSlow</h2>

<p>该算法的内循环为 <code>if (nums[i] + nums[j] + nums[k] == 0)</code> 语句，总共执行的次数为 N(N-1)(N-2) = N<sup>3</sup>/6-N<sup>2</sup>/2+N/3，因此它的近似执行次数为 ~N<sup>3</sup>/6，增长数量级为 O(N<sup>3</sup>)。</p>

<pre><code class="language-java">
public class ThreeSumSlow implements ThreeSum {

    @Override

    public int count(int[] nums) {

        int N = nums.length;

        int cnt = 0;

        for (int i = 0; i &lt; N; i++) {

            for (int j = i + 1; j &lt; N; j++) {

                for (int k = j + 1; k &lt; N; k++) {

                    if (nums[i] + nums[j] + nums[k] == 0) {

                        cnt++;

                    }

                }

            }

        }

        return cnt;

    }

}

</code></pre>

<h2 id="2-threesumbinarysearch">2. ThreeSumBinarySearch</h2>

<p>将数组进行排序，对两个元素求和，并用二分查找方法查找是否存在该和的相反数，如果存在，就说明存在和为 0 的三元组。</p>

<p>应该注意的是，只有数组不含有相同元素才能使用这种解法，否则二分查找的结果会出错。</p>

<p>该方法可以将 ThreeSum 算法增长数量级降低为 O(N<sup>2</sup>logN)。</p>

<pre><code class="language-java">
public class ThreeSumBinarySearch implements ThreeSum {



    @Override

    public int count(int[] nums) {

        Arrays.sort(nums);

        int N = nums.length;

        int cnt = 0;

        for (int i = 0; i &lt; N; i++) {

            for (int j = i + 1; j &lt; N; j++) {

                int target = -nums[i] - nums[j];

                int index = BinarySearch.search(nums, target);

                // 应该注意这里的下标必须大于 j，否则会重复统计。

                if (index &gt; j) {

                    cnt++;

                }

            }

        }

        return cnt;

    }

}

</code></pre>

<pre><code class="language-java">
public class BinarySearch {



    public static int search(int[] nums, int target) {

        int l = 0, h = nums.length - 1;

        while (l &lt;= h) {

            int m = l + (h - l) / 2;

            if (target == nums[m]) {

                return m;

            } else if (target &gt; nums[m]) {

                l = m + 1;

            } else {

                h = m - 1;

            }

        }

        return -1;

    }

}

</code></pre>

<h2 id="3-threesumtwopointer">3. ThreeSumTwoPointer</h2>

<p>更有效的方法是先将数组排序，然后使用双指针进行查找，时间复杂度为 O(N<sup>2</sup>)。</p>

<p>同样不适用与数组存在重复元素的情况。</p>

<pre><code class="language-java">
public class ThreeSumTwoPointer implements ThreeSum {



    @Override

    public int count(int[] nums) {

        int N = nums.length;

        int cnt = 0;

        Arrays.sort(nums);

        for (int i = 0; i &lt; N - 2; i++) {

            int l = i + 1, h = N - 1, target = -nums[i];

            while (l &lt; h) {

                int sum = nums[l] + nums[h];

                if (sum == target) {

                    cnt++;

                    l++;

                    h--;

                } else if (sum &lt; target) {

                    l++;

                } else {

                    h--;

                }

            }

        }

        return cnt;

    }

}

</code></pre>

<h1 id="倍率实验">倍率实验</h1>

<p>如果 T(N) ~ aN<sup>b</sup>logN，那么 T(2N)/T(N) ~ 2<sup>b</sup>。</p>

<p>例如对于暴力的 ThreeSum 算法，近似时间为 ~N<sup>3</sup>/6。进行如下实验：多次运行该算法，每次取的 N 值为前一次的两倍，统计每次执行的时间，并统计本次运行时间与前一次运行时间的比值，得到如下结果：</p>

<p>| N | Time(ms) | Ratio |</p>

<p>| :&mdash;: | :&mdash;: | :&mdash;: |</p>

<p>| 500 | 48 | / |</p>

<p>| 1000 | 320 | 6.7 |</p>

<p>| 2000 | 555 | 1.7 |</p>

<p>| 4000 | 4105 | 7.4 |</p>

<p>| 8000 | 33575 | 8.2 |</p>

<p>| 16000 | 268909 | 8.0 |</p>

<p>可以看到，T(2N)/T(N) ~ 2<sup>3</sup>，因此可以确定 T(N) ~ aN<sup>3</sup>logN。</p>

<pre><code class="language-java">
public class RatioTest {



    public static void main(String[] args) {

        int N = 500;

        int loopTimes = 7;

        double preTime = -1;

        while (loopTimes-- &gt; 0) {

            int[] nums = new int[N];

            StopWatch.start();

            ThreeSum threeSum = new ThreeSumSlow();

            int cnt = threeSum.count(nums);

            System.out.println(cnt);

            double elapsedTime = StopWatch.elapsedTime();

            double ratio = preTime == -1 ? 0 : elapsedTime / preTime;

            System.out.println(N + &quot;  &quot; + elapsedTime + &quot;  &quot; + ratio);

            preTime = elapsedTime;

            N *= 2;

        }

    }

}

</code></pre>

<pre><code class="language-java">
public class StopWatch {



    private static long start;





    public static void start() {

        start = System.currentTimeMillis();

    }





    public static double elapsedTime() {

        long now = System.currentTimeMillis();

        return (now - start) / 1000.0;

    }

}

</code></pre>


  

  
  <hr>
  <footer>

  
    <section>
    <h4>Share</h4>
    <nav class="nav sharing-icons">
      <a class="nav-item" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fjiakuanzhu.github.io%2f2019%2f10%2fmodel%2f" title="Share on Facebook"><span class="fa fa-facebook fa-2x" aria-hidden="true"></span></a>
      <a class="nav-item" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjiakuanzhu.github.io%2f2019%2f10%2fmodel%2f" title="Share on LinkedIn"><span class="fa fa-linkedin fa-2x" aria-hidden="true"></span></a>
      <a class="nav-item" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fjiakuanzhu.github.io%2f2019%2f10%2fmodel%2f&amp;text=Model" title="Tweet this"><span class="fa fa-twitter fa-2x"></span></a>
    </nav>
  </section>

  

  
  </footer>
  

</article> 



        </div> <!-- /.blog-main -->

        <aside class="col-sm-3 ml-auto blog-sidebar">
  
  <section class="sidebar-module sidebar-module-inset">
    <h4>About</h4>
    <p dir="auto">A simple Hugo theme based on the <a href="http://v4-alpha.getbootstrap.com/examples/blog/">Bootstrap v4 blog example</a>.</p>
  </section>
  

  
        <section class="sidebar-module">
    <h4>Recent Posts</h4>
    <ol class="list-unstyled">


<li><a href="/2014/09/creating-a-new-theme/">Creating a New Theme</a></li>

<li><a href="/2014/03/migrate-to-hugo-from-jekyll/">Migrate to Hugo from Jekyll</a></li>

<li><a href="/2019/10/algschap1/">AlgsChap1</a></li>

<li><a href="/2019/10/model/">Model</a></li>

<li><a href="/2014/04/hugo-template-primer/">(Hu)go Template Primer</a></li>

    </ol>
  </section>

  

  
  <section class="sidebar-module">
    <h4>Links</h4>
    <ol class="list-unstyled">
      
      <li><a href="https://example.com">Link 1</a></li>
      
      <li><a href="https://example.org">Link 2</a></li>
      
    </ol>
  </section>
  
</aside>


      </div> <!-- /.row -->
    </div> <!-- /.container -->
    

    
    <footer class="blog-footer">
      <p dir="auto">
      
      Blog template created by <a href="https://twitter.com/mdo">@mdo</a>, ported to Hugo by <a href='https://twitter.com/mralanorth'>@mralanorth</a>.
      
      </p>
      <p>
      <a href="#">Back to top</a>
      </p>
    </footer>
    

  </body>

</html>
